searchState.loadedDescShard("monitor", 0, "Contains raw mapping addresses, for use when translating …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReserved instance ID for the security monitor.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA security monitor instance. All monitor logic is …\nOpen handles to compartments.\nWrite bytes to this per-compartment thread’s simple …\nManagement of compartments.\nRead the name of a compartment.\nPerform a compartment control action on the calling …\nDrop a compartment handle.\nDrop a library handle.\nDynamic linker state.\nReturns the argument unchanged.\nGet the compartment config for the given compartment.\nOpen a handle to the n’th dependency compartment of a …\nGet CompartmentInfo for this caller. Note that this will …\nOpen a compartment handle for this caller compartment.\nGet CompartmentInfo for this caller. Note that this will …\nGet the n’th thread’s info from a compartment.\nOpen a handle to the n’th library for a compartment.\nGet LibraryInfo for a given library handle. Note that this …\nGet the monitor instance. Panics if called before first …\nGet the object ID for this compartment-thread’s simple …\nCalls <code>U::from(self)</code>.\nOpen handles to libraries.\nLoad a new compartment with a root library ID, and return …\nLoad a library in the given compartment.\nOpen a compartment handle for this caller compartment.\nMap an object into a given compartment.\nMap a pair of objects into a given compartment.\nBuild a new monitor state from the initial dynamic linker …\nRead bytes from this per-compartment thread’s simple …\nSet the monitor instance. Can only be called once. Must be …\nManagement of address space.\nSpawn a thread into a given compartment, using initial …\nStart the background threads for the monitor instance. …\nStart a managed monitor thread.\nManagement of all threads.\nUnmap an object from a given compartmen.\nA handle to a compartment.\nManages compartments.\nGet an iterator over all compartments.\nGet a RunComp by dynamic linker ID.\nGet the RunComp for the monitor.\nGet the RunComp for the monitor.\nGet a RunComp by name.\nGet an iterator over all compartments (mutable).\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a RunComp by instance ID.\nGet a RunComp by dynamic linker ID.\nGet a RunComp by instance ID.\nGet a RunComp by name.\nInsert a RunComp.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRemove a RunComp.\nManages a compartment configuration object.\nReturn a span that can be used for allocations in the comp …\nReturns the argument unchanged.\nGet a pointer to this comp config data.\nCalls <code>U::from(self)</code>.\nCreate a new CompConfigObject from a handle. Initializes …\nRead the comp config data.\nWrite a comp config to this object.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the entry frame for this thread into a given …\nGet the initial stack pointer.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStart a new thread using the given stack, in the provided …\nMake a new stack object from a given handle and stack size.\nGet the start start address for the compartment.\nGet the stack size.\nA single compartment, loaded but not yet running.\nTracks info for loaded, but not yet running, compartments.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBuild a new RunCompLoader. This will load and relocate …\nCompartment destructors have run.\nCompartment thread has exited.\nCompartment is a binary, not a library.\nCompartment is ready (loaded, reloacated, runtime started …\nCompartment thread has been started once.\nCompartment runtime thread may exit.\nPer-thread data in a compartment.\nA runnable or running compartment.\nSet a flag on this compartment, and wakeup anyone waiting …\nRemove all per-thread data for a given thread.\nGet a pointer to the compartment config.\nThe dynlink ID of this compartment.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet per-thread data in this compartment.\nCheck if a flag is set.\nThe instance of the security context.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMap an object into this compartment.\nAllocate some space in the compartment allocator, and …\nAllocate some space in the compartment allocator for a …\nThe name of this compartment.\nBuild a new runtime compartment.\nCreate a new PerThread. Note that this must succeed, so …\nGet the raw flags bits for this RC.\nRead bytes from this compartment-thread’s simple buffer.\nThe security context for this compartment.\nSet a flag on this compartment, and wakeup anyone waiting …\nGet the Object ID of this compartment thread’s simple …\nUnmap and object from this compartment.\nSetup a ThreadSyncSleep for waiting until the flag is set. …\nWrite bytes into this compartment-thread’s simple buffer.\nA handle to a library.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA mapping of an object and flags.\nAn address space we can map objects into.\nAllows us to call handle_drop and do all the hard work in …\nMap an object into the address space, without tracking it. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRemove an object from the space. The actual unmapping …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMap an object into the space.\nMap a pair of objects into the space.\nUtility function for creating an object and mapping it, …\nGet the stats.\nA shared map handle.\nA handle for an object mapped into the address space. This …\nGet the mapped addresses of this handle.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGet a pointer to the base address of the object.\nGet a pointer to the start address of the object.\nCreate a new map handle.\nManages a background thread that unmaps mappings.\nEnqueue a mapping to be unmapped.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMake a new unmapper.\nDefault stack size for the user stack.\nA thread managed by the monitor.\nInternal managed thread data.\nAn owned handle to a thread’s repr object.\nStack minimium alignment.\nStack size for the supervisor upcall stack.\nManages all threads owned by the monitor. Typically, this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the thread representation structure for the associated …\nCheck if this thread has exited.\nThe ID of the thread.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe thread repr.\nStart a thread, running the provided Box’d closure. The …\nCreate a ThreadSyncSleep that will wait until the thread …\nTracks threads that do not exit cleanly, so their …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMakes a new ThreadCleaner.\nNotify the cleanup thread that new items are on the queue.\nTrack a thread. If that thread exits, the cleanup thread …\nUntrack a thread. Threads removed this way do not trigger …")