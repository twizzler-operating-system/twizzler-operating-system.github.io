<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Provides a duplex send/completion queue, where each direction is multiple-producer/single-consumer."><title>twizzler_queue - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-b0742ba02757f159.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="twizzler_queue" data-themes="" data-resource-suffix="" data-rustdoc-version="1.84.0-dev" data-channel="nightly" data-search-js="search-e056c65ede92db13.js" data-settings-js="settings-805db61a62df4bd2.js" ><script src="../static.files/storage-1d39b6787ed640ff.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f070b9041d14864c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-0111fcff984fae8f.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../twizzler_queue/index.html">twizzler_<wbr>queue</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>twizzler_queue</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/twizzler_queue/lib.rs.html#1-26">source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Provides a duplex send/completion queue, where each direction is
multiple-producer/single-consumer.</p>
<p>The core queue abstraction is built around two subqueues, each providing an MPSC
interface. These subqueues are stored in a single object, and so the verbs to interact with the
two subqueues are different.</p>
<p>Generally a queue is thought of as providing a connection between a sender and a receiver, where
the sender sends requests to the receiver, and the receiver indications completion of requests.
Hence, one subqueue is the sending queue and the other is the completion queue. The subqueue
implementation is provided by the twizzler-queue-raw crate. This crate connects that crate to
the object system of Twizzler.</p>
<p>The queues also provide hooks for asynchrony, allowing a given call to be non-blocking, and
methods to hook into for async executors to wait on events on a queue.</p>
<p>Each subqueue sends a type T across the queue via byte-level copy. Internally, these objects are
held in a circular buffer with a maximum length specified on queue creation.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">ยง</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.CallbackQueueReceiver.html" title="struct twizzler_queue::CallbackQueueReceiver">Callback<wbr>Queue<wbr>Receiver</a></div><div class="desc docblock-short">A receiver-side async-enabled queue abstraction.</div></li><li><div class="item-name"><a class="struct" href="struct.Queue.html" title="struct twizzler_queue::Queue">Queue</a></div><div class="desc docblock-short">A single queue, holding two subqueues (sending and completion). Objects of type S are sent
across the sending queue, and completions of type C are sent back.</div></li><li><div class="item-name"><a class="struct" href="struct.QueueBase.html" title="struct twizzler_queue::QueueBase">Queue<wbr>Base</a></div><div class="desc docblock-short">The base info structure stored in a Twizzler queue object. Used to open Twizzler queue objects
and create a [Queue].</div></li><li><div class="item-name"><a class="struct" href="struct.QueueSender.html" title="struct twizzler_queue::QueueSender">Queue<wbr>Sender</a></div><div class="desc docblock-short">An async-supported sending-half of a <a href="struct.Queue.html" title="struct twizzler_queue::Queue">Queue</a>. This is to support systems that want to
asynchronously send items to a receiver, under the assumption that the receiver sends
completions to indicate that a request has been finished, and that the send ID can be reused.</div></li><li><div class="item-name"><a class="struct" href="struct.ReceiveFlags.html" title="struct twizzler_queue::ReceiveFlags">Receive<wbr>Flags</a></div><div class="desc docblock-short">Flags to control how queue receive works.</div></li><li><div class="item-name"><a class="struct" href="struct.SubmissionFlags.html" title="struct twizzler_queue::SubmissionFlags">Submission<wbr>Flags</a></div><div class="desc docblock-short">Flags to control how queue submission works.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">ยง</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.QueueError.html" title="enum twizzler_queue::QueueError">Queue<wbr>Error</a></div><div class="desc docblock-short">Possible errors for submitting to a queue.</div></li></ul></section></div></main></body></html>