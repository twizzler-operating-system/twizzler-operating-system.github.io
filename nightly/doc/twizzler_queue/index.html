<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Provides a duplex send/completion queue, where each direction is multiple-producer/single-consumer."><title>twizzler_queue - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="twizzler_queue" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0-dev" data-channel="nightly" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../static.files/storage-82c7156e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../twizzler_queue/index.html">twizzler_<wbr>queue</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>twizzler_queue</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/twizzler_queue/lib.rs.html#1-26">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Provides a duplex send/completion queue, where each direction is
multiple-producer/single-consumer.</p>
<p>The core queue abstraction is built around two subqueues, each providing an MPSC
interface. These subqueues are stored in a single object, and so the verbs to interact with the
two subqueues are different.</p>
<p>Generally a queue is thought of as providing a connection between a sender and a receiver, where
the sender sends requests to the receiver, and the receiver indications completion of requests.
Hence, one subqueue is the sending queue and the other is the completion queue. The subqueue
implementation is provided by the twizzler-queue-raw crate. This crate connects that crate to
the object system of Twizzler.</p>
<p>The queues also provide hooks for asynchrony, allowing a given call to be non-blocking, and
methods to hook into for async executors to wait on events on a queue.</p>
<p>Each subqueue sends a type T across the queue via byte-level copy. Internally, these objects are
held in a circular buffer with a maximum length specified on queue creation.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="struct" href="struct.CallbackQueueReceiver.html" title="struct twizzler_queue::CallbackQueueReceiver">Callback<wbr>Queue<wbr>Receiver</a></dt><dd>A receiver-side async-enabled queue abstraction.</dd><dt><a class="struct" href="struct.Queue.html" title="struct twizzler_queue::Queue">Queue</a></dt><dd>A single queue, holding two subqueues (sending and completion). Objects of type S are sent
across the sending queue, and completions of type C are sent back.</dd><dt><a class="struct" href="struct.QueueBase.html" title="struct twizzler_queue::QueueBase">Queue<wbr>Base</a></dt><dd>The base info structure stored in a Twizzler queue object. Used to open Twizzler queue objects
and create a Queue.</dd><dt><a class="struct" href="struct.QueueSender.html" title="struct twizzler_queue::QueueSender">Queue<wbr>Sender</a></dt><dd>An async-supported sending-half of a <a href="struct.Queue.html" title="struct twizzler_queue::Queue">Queue</a>. This is to support systems that want to
asynchronously send items to a receiver, under the assumption that the receiver sends
completions to indicate that a request has been finished, and that the send ID can be reused.</dd><dt><a class="struct" href="struct.ReceiveFlags.html" title="struct twizzler_queue::ReceiveFlags">Receive<wbr>Flags</a></dt><dd>Flags to control how queue receive works.</dd><dt><a class="struct" href="struct.SubmissionFlags.html" title="struct twizzler_queue::SubmissionFlags">Submission<wbr>Flags</a></dt><dd>Flags to control how queue submission works.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="enum" href="enum.QueueError.html" title="enum twizzler_queue::QueueError">Queue<wbr>Error</a></dt><dd>Possible errors for submitting to a queue.</dd></dl></section></div></main></body></html>