<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Wait for receiving on multiple raw queues. If any of the passed raw queues can return data, they will do so by writing it into the output array at the same index that they are in the `queues` variable. The queues and output arrays must be the same length. If no data is available in any queues, then the function will call back on multi_wait, which it expects to wait until any of the pairs (&amp;x, y) meet the condition that *x != y. Before returning any data, the function will callback on multi_ring, to inform multiple queues that data was taken from them. It expects the multi_ring function to wake up any waiting threads on the supplied words of memory."><title>multi_receive in twizzler_queue_raw - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-085727c29c2fa99e.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="twizzler_queue_raw" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.0-dev" data-channel="nightly" data-search-js="search-cfcb9d78f851226e.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-c5bd66d33317d69f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../twizzler_queue_raw/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a></nav><nav class="sidebar"><a class="logo-container" href="../twizzler_queue_raw/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><div class="sidebar-elems"><h2><a href="index.html">In twizzler_queue_raw</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="index.html">twizzler_queue_raw</a>::<wbr><a class="fn" href="#">multi_receive</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/twizzler_queue_raw/lib.rs.html#539-581">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub fn multi_receive&lt;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>, W: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(&amp;[(<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="https://doc.rust-lang.org/nightly/core/sync/atomic/struct.AtomicU64.html" title="struct core::sync::atomic::AtomicU64">AtomicU64</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>)]), R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(&amp;[<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="https://doc.rust-lang.org/nightly/core/sync/atomic/struct.AtomicU64.html" title="struct core::sync::atomic::AtomicU64">AtomicU64</a>&gt;])&gt;(
    queues: &amp;[&amp;<a class="struct" href="struct.RawQueue.html" title="struct twizzler_queue_raw::RawQueue">RawQueue</a>&lt;T&gt;],
    output: &amp;mut [<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.QueueEntry.html" title="struct twizzler_queue_raw::QueueEntry">QueueEntry</a>&lt;T&gt;&gt;],
    multi_wait: W,
    multi_ring: R,
    flags: <a class="struct" href="struct.ReceiveFlags.html" title="struct twizzler_queue_raw::ReceiveFlags">ReceiveFlags</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="enum" href="enum.QueueError.html" title="enum twizzler_queue_raw::QueueError">QueueError</a>&gt;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Wait for receiving on multiple raw queues. If any of the passed raw queues can return data, they
will do so by writing it into the output array at the same index that they are in the <code>queues</code>
variable. The queues and output arrays must be the same length. If no data is available in any
queues, then the function will call back on multi_wait, which it expects to wait until <strong>any</strong>
of the pairs (&amp;x, y) meet the condition that *x != y. Before returning any data, the function
will callback on multi_ring, to inform multiple queues that data was taken from them. It expects
the multi_ring function to wake up any waiting threads on the supplied words of memory.</p>
<p>Note that both call backs specify the pointers as Option. In the case that an entry is None,
there was no requested wait or wake operation for that queue, and that entry should be ignored.</p>
<p>If flags specifies <a href="struct.ReceiveFlags.html#associatedconstant.NON_BLOCK" title="associated constant twizzler_queue_raw::ReceiveFlags::NON_BLOCK">ReceiveFlags::NON_BLOCK</a>, then if no data is available, the function returns
immediately with Err(<a href="enum.QueueError.html#variant.WouldBlock" title="variant twizzler_queue_raw::QueueError::WouldBlock">QueueError::WouldBlock</a>).</p>
<h2 id="rationale"><a href="#rationale">Rationale</a></h2>
<p>This function is here to implement poll or select like functionality, wherein a given thread or
program wants to wait on multiple incoming request channels and handle them itself, thus cutting
down on the number of threads required. The maximum number of queues to use here is a trade-off
— more means fewer threads, but since this function is linear in the number of queues, each
thread could take longer to service requests.</p>
<p>The complexity of the multi_wait and multi_ring callbacks is present to avoid calling into the
kernel often for high-contention queues.</p>
</div></details></section></div></main></body></html>