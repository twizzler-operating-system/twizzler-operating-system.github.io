initSidebarItems({"fn":[["block_on","Run a future to completion, sleeping the thread if there is no progress that can be made."],["run","Runs executors."],["timeout_after","Await a future until a timeout occurs (or that future completes). If the timeout happens, return None, otherwise return Some of the result of the future. This timeout expires after a duration."],["timeout_at","Await a future until a timeout occurs (or that future completes). If the timeout happens, return None, otherwise return Some of the result of the future. This timeout expires at an instant in time."],["wait_for_first","A future that waits on two sub-futures until the first one completes. If the second one completes first, this future will continue awaiting on the first future. If the first one completes first, this future returns immediately without continuing to wait on the second future."]],"struct":[["Async","A wrapper type around some “handle” that we want to perform asynchronous operations on, where that handle must implement [AsyncSetup]."],["AsyncDuplex","A wrapper type around some “handle” that we want to perform asynchronous operations on, where that handle must implement [AsyncDuplexSetup]."],["FlagBlock","A basic condition variable for async tasks. If you call wait() you get back a future that you can await on, which will complete once another tasks calls signal_all(). But there’s a gotcha here."],["Task","A spawned future. Tasks are futures themselves and yield the output of the spawned future."],["Timer","A timer future that returns after a specified period of time."]],"trait":[["AsyncDuplexSetup","Implement setting up externally signaled asynchronous events for the async runner to wait for, in the case where there is a duplex mode for reading and writing to this object, each of which could fail with some “would block” error."],["AsyncSetup","Implement setting up externally signaled asynchronous events for the async runner to wait for, in the case where there is a single “runnable” abstraction for this object."]]});