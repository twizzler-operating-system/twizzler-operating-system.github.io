<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Twizzler Operating System</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="BUILD.html">Building Twizzler</a></li><li class="chapter-item expanded affix "><a href="develop.html">Developing on Twizzler</a></li><li class="chapter-item expanded affix "><a href="Debug.html">Debugging Twizzler</a></li><li class="chapter-item expanded affix "><li class="part-title">Fundamentals</li><li class="chapter-item expanded "><a href="Object.html"><strong aria-hidden="true">1.</strong> Objects</a></li><li class="chapter-item expanded "><a href="Lifetime.html"><strong aria-hidden="true">2.</strong> Object Lifetime</a></li><li class="chapter-item expanded "><a href="Pointer.html"><strong aria-hidden="true">3.</strong> Pointers</a></li><li class="chapter-item expanded "><a href="Permissions.html"><strong aria-hidden="true">4.</strong> Permissions</a></li><li class="chapter-item expanded "><a href="ReferenceRuntime.html"><strong aria-hidden="true">5.</strong> Reference Runtime</a></li><li class="chapter-item expanded affix "><li class="part-title">Primitives</li><li class="chapter-item expanded "><a href="Views.html"><strong aria-hidden="true">6.</strong> Views</a></li><li class="chapter-item expanded "><a href="KSO.html"><strong aria-hidden="true">7.</strong> Kernel State Objects</a></li><li class="chapter-item expanded "><a href="Extensions.html"><strong aria-hidden="true">8.</strong> Extensions</a></li><li class="chapter-item expanded "><a href="Gates.html"><strong aria-hidden="true">9.</strong> Gates</a></li><li class="chapter-item expanded affix "><li class="part-title">Driver Development</li><li class="chapter-item expanded "><a href="DMA.html"><strong aria-hidden="true">10.</strong> DMA</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Features</li><li class="chapter-item expanded "><a href="Trace.html"><strong aria-hidden="true">11.</strong> Tracing and Performance Debugging</a></li><li class="chapter-item expanded "><a href="CargoMetadata.html"><strong aria-hidden="true">12.</strong> Twizzler Build System Crate Metadata</a></li><li class="chapter-item expanded affix "><li class="part-title">Other</li><li class="chapter-item expanded "><a href="AssortedNotes.html"><strong aria-hidden="true">13.</strong> Assorted Notes</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Twizzler Operating System</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="user-space-primitive-documentation"><a class="header" href="#user-space-primitive-documentation">User Space Primitive Documentation</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>This documentation is largely still a collection of notes based off the previous C-based Twizzler
system, and is being updated to reflect new APIs.</p>
<h2 id="where-to-begin"><a class="header" href="#where-to-begin">Where to begin</a></h2>
<p>Twizzler introduces objects to organize persistent data, rather than files in traditional systems. This provides the benefit of not having to serialize and deserialize data to make it persistent.</p>
<p>Pages explaining the  main abstractions of the OS are available at the following links: <a href="./Object.html">Objects</a> (for the main data abstraction), <a href="./Views.html">Views</a> (for thread environments), and <a href="./KSO.html">Kernel State Objects</a> (the security model). From these basics, there are a number of features provided by the Twizzler userspace that can be used to enhance programs, but are not necessary for understanding the fundamentals of the OS.</p>
<ul>
<li>To get a background on the motivations and a high level understanding of the goals of the operating system, we recommend <a href="https://dl.acm.org/doi/10.1145/3454129">Twizzler: a Data-Centric OS for Non-Volatile Memory</a>. This is a research paper explaining the system for academic readers.</li>
<li>To just jump in, follow the <a href="./BUILD.html">build guide</a> and look at <a href="https://twizzler-operating-system.github.io/nightly/doc/">the code documentation</a> (essentially manual pages) for primitive functions.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-twizzler"><a class="header" href="#building-twizzler">Building Twizzler</a></h1>
<p>A bit of a time consuming process the first time, so make sure you have some nice tea or something before you start :)</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>This build process has been tested on an Ubuntu 20.04 system with standard development tools
installed, in addition to rustup (which is required). We require rustup because we will build our
own toolchain during the build, and link the result through rustup for easier invocation of the Rust
compiler.</p>
<p>To build a boot image, you'll need the limine bootloader installed. In particular, we need the EFI
code to help boot Twizzler through their boot protocol.</p>
<p>To run qemu through the build system, you'll need qemu installed.</p>
<h2 id="wsl-setup"><a class="header" href="#wsl-setup">WSL Setup</a></h2>
<p>WSL needs additional setup to enable KVM virtualization:</p>
<ol>
<li>
<p><strong>Enable nested virtualization</strong> - Add to <code>.wslconfig</code> in your Windows user directory (you may have to create the file):</p>
<pre><code>[wsl2]
nestedVirtualization=true
</code></pre>
</li>
<li>
<p><strong>Add yourself to <code>kvm</code> group</strong> - In WSL:</p>
<pre><code>sudo usermod -a -G kvm ${USER}
</code></pre>
</li>
<li>
<p><strong>Change default group of <code>/dev/kvm</code></strong> - Add to <code>/etc/wsl.conf</code> in WSL:</p>
<pre><code>[boot]
command = /bin/bash -c 'chown -v root:kvm /dev/kvm &amp;&amp; chmod 660 /dev/kvm'
</code></pre>
</li>
<li>
<p><strong>Restart WSL</strong></p>
<pre><code>wsl --shutdown
</code></pre>
</li>
</ol>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Installing the tools:</p>
<ol>
<li>sudo apt install build-essential python3 python3-pip cmake ninja-build</li>
<li>Install Rust https://www.rust-lang.org/tools/install</li>
</ol>
<p>Note that you'll need mke2fs (typically found in e2fsprogs). Most Linux installations should already have this
command available. On MacOS, with brew, it can be installed with <code>brew install e2fsprogs</code>.</p>
<p>Note that we depend on the system LLVM for some initial bindgen commands. The minimum version for this is 18.</p>
<p>On ubuntu, this can be selected for building twizzler by env vars: <code>export LLVM_CONFIG_PATH=/usr/bin/llvm-config-18</code>.</p>
<ul>
<li>Note that its possible for the build system to work without this export, but if something is broken and you havent done this step, its best to start here.</li>
</ul>
<p>See here: https://apt.llvm.org/ for install instructions. You may need to <code>export LLVM_CONFIG_PATH=/usr/bin/llvm-config-18</code>.</p>
<p>Building Twizzler is done in several steps:</p>
<ol start="0">
<li>Building xtask.</li>
<li>Building the toolchain.</li>
<li>Building Twizzler itself.</li>
</ol>
<p>Fortunately, step 0 is handled automatically whenever we try to do anything. That's because xtask is
the &quot;build system orchestrator&quot;. Essentially, building Twizzler requires using the right toolchain,
target specification, and compile flags at the right times, so we've placed that complexity in an
automation tool to make builds easier. To get an idea of what xtask is doing, you can run
<code>cargo xtask --help</code>. Note that this repo's cargo config provides aliases for the common commands,
as we will see below. In fact, it's advisable to NOT use the default cargo commands, and instead run
everything through xtask.</p>
<h2 id="step-1-building-the-toolchain"><a class="header" href="#step-1-building-the-toolchain">Step 1: Building the Toolchain</a></h2>
<p>This step takes the longest, but only has to happen once. Run</p>
<pre><code>cd where/you/cloned/twizzler
git submodule update --init --recursive
cargo bootstrap
</code></pre>
<p>and then wait, while you sip your tea. This will compile llvm and bootstrap the rust compiler, both
of which take a long time. At the end, you should see a &quot;build completed successfully&quot; message,
followed by a few lines about building crti and friends.</p>
<h2 id="step-2-building-twizzler"><a class="header" href="#step-2-building-twizzler">Step 2: Building Twizzler</a></h2>
<p>Now that we've got the toolchain built and linked, we can compile the rest of Twizzler. Run</p>
<pre><code>cargo build-all
</code></pre>
<p>which will compile several &quot;collections&quot; of packages:</p>
<ol>
<li>The build tools, for things like making the initrd.</li>
<li>The kernel.</li>
<li>The userspace applications.</li>
</ol>
<p>By default all will be built in debug mode, which will run very slow. You can build for release mode
with:</p>
<pre><code>cargo build-all --profile release
</code></pre>
<h2 id="step-3-running-twizzler"><a class="header" href="#step-3-running-twizzler">Step 3: Running Twizzler</a></h2>
<p>You can start Twizzler in Qemu by running</p>
<pre><code>cargo start-qemu
</code></pre>
<p>which will bootup a qemu instance. If you want to run the release mode version, you can run</p>
<pre><code>cargo start-qemu --profile release
</code></pre>
<p>When running from command line, if you don't have access to a screen, QEMU may require you add <code>-q=-nographic</code> to the command.</p>
<h2 id="step-4-exiting-twizzler"><a class="header" href="#step-4-exiting-twizzler">Step 4: Exiting Twizzler</a></h2>
<p>At the moment Twizzler does not have a shutdown command.  To exit the QEMU based simulation use the <code>Ctrl-a X</code> command which is a part of the simulator.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developing-for-twizzler"><a class="header" href="#developing-for-twizzler">Developing for Twizzler</a></h1>
<p>The Twizzler project welcomes people to contribute to this open source
operating system.  We follow a branch and pull-request process.  For
those without write access to the repo you will first have to fork the
Twizzler repo, for those with write access it's easier to work within
the main repo in your own branches.</p>
<h2 id="writing-your-first-twizzler-program"><a class="header" href="#writing-your-first-twizzler-program">Writing your First Twizzler Program</a></h2>
<p>Twizzler makes heavy use of Rust's Cargo system of crates in order to manage both kernel and user space programs.  To create a new program that
runs on the Twizzler operating system you can follow these steps:</p>
<ol>
<li>Change directories into the bin directory:</li>
</ol>
<p><code>cd twizzler/src/bin</code></p>
<ol start="2">
<li>
<p>Create a new program, named <code>hello</code>.  The <code>Cargo</code> command will actually create the canonical <code>Hello world</code> program for you.
<code>cargo new --bin hello</code></p>
</li>
<li>
<p>Change directory back to the project root, and edit the Cargo.toml file in the root directory to add the program to the Twizzler build system.</p>
</li>
</ol>
<p>The following diff shows the two lines you need to add:</p>
<pre><code class="language-diff">diff --git a/Cargo.toml b/Cargo.toml
index 338455b..cb38fb5 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -7,6 +7,7 @@ members = [
     &quot;src/bin/devmgr&quot;,
     &quot;src/bin/netmgr&quot;,
     &quot;src/bin/nettest&quot;,
+    &quot;src/bin/hello&quot;,
     &quot;src/kernel&quot;,
     &quot;src/lib/twizzler-queue-raw&quot;,
     &quot;src/lib/twizzler-queue&quot;,
@@ -21,10 +22,11 @@ initrd = [
     &quot;crate:devmgr&quot;,
     &quot;crate:netmgr&quot;,
     &quot;crate:nettest&quot;,
+    &quot;crate:hello&quot;,
 ]
</code></pre>
<ol start="4">
<li>Rebuild the system and start QEMU</li>
</ol>
<p><code>cargo start-qemu</code></p>
<ol start="5">
<li>From within Twizzler run your new program</li>
</ol>
<pre><code>run hello
got: &lt;run hello&gt;
&gt; Hello, world!
</code></pre>
<ol start="6">
<li>Exit the simulator with <code>Ctrl-a x</code></li>
</ol>
<h2 id="picking-an-issue-to-work"><a class="header" href="#picking-an-issue-to-work">Picking an Issue to Work</a></h2>
<p>Before reading this document make sure that you have worked through the build process, which is documented
<a href="https://github.com/twizzler-operating-system/twizzler/doc/src/BUILD.md">here</a>.</p>
<p>After reading this document, if you would like to work on an open issue,
you can take a look at a
<a href="https://github.com/twizzler-operating-system/twizzler/issues">list of issues</a>.
For newer contributors, easier issues are tagged
<a href="https://github.com/twizzler-operating-system/twizzler/labels/good%20first%20issue">good first issue</a>
and are a good place to dive in.</p>
<h2 id="branch-naming"><a class="header" href="#branch-naming">Branch Naming</a></h2>
<p>Branch names should be short and descriptive, containing the user's
github or other short name, following by a dash and then a feature
name, e.g. gnn-icmp.  Names must not violate the Twizzler project's
Code of Conduct.  Please keep it classy.</p>
<h2 id="submitting-a-pull-request"><a class="header" href="#submitting-a-pull-request">Submitting a Pull Request</a></h2>
<p>All pull requests should be against the 'main' branch.  From time to
time there may be special exceptions but these must be coordinated
with the project owners, listed on the main github page.</p>
<h2 id="example-workflow"><a class="header" href="#example-workflow">Example Workflow</a></h2>
<p>In order to create this set of documentation the following steps were
carried out.</p>
<pre><code>&gt; git clone git@github.com:twizzler-operating-system/twizzler.git
</code></pre>
<p>Create and edit file in doc/src/develop.md</p>
<pre><code>&gt; git branch -b gnn-docs
&gt; git add doc/src/develop.md
&gt; git commit
&gt; git push --set-upstream origin gnn-docs
</code></pre>
<p>The pull request was then submitted from the github page for the
Twizzer project.</p>
<p>Two reviewers were added at the time the PR was committed.</p>
<h1 id="coding-standards"><a class="header" href="#coding-standards">Coding Standards</a></h1>
<p>Code submitted to Twizzler must follow these guidelines:</p>
<ul>
<li>Follow the Rust style guide. This is just the default style for all rust code established by <code>rustfmt</code>, explained at <a href="https://github.com/rust-lang/rustfmt#readme">this GitHub repository</a>.</li>
<li>Be well documented. Please add documentation to explain your code. For more information on this, see below.</li>
<li>For unsafe code, have special safety documentation to explain why the code must be unsafe, and extra scrutiny on that code to ensure its correctness.</li>
<li>Pass <a href="https://github.com/rust-lang/rust-clippy#readme">clippy</a>, the rust linter. It is useful for finding common mistakes and improving code.</li>
</ul>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>If you want to document code instead of writing it, thank you! Rust has a built-in documentation tool <code>rustdoc</code> which makes compiling documentation easier, and writing it directly in the code more natural. <a href="https://doc.rust-lang.org/cargo/index.html">Documentation explanation</a>. Contributions can be made through pull requests, just like for code, explained above.</p>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Twizzler supports an integrated testing system, where kernel test harnesses and userspace test
programs for libraries and binaries are run on start-up. You can run Twizzler in test mode by adding
the <code>--tests</code> argument to your cargo run commands.</p>
<p>When developing for Twizzler, you should write tests that cover code you wrote. This includes both
userspace and kernelspace code. Note that writing tests for the kernel is slightly different, in
that a test-case failing causes the whole system to stop, and you need to use the <code>#[kernel_test]</code>
attribute from the <code>twizzler-kernel-macros</code> crate instead of <code>#[test]</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>Debugging support is in-progress on Twizzler. Currently, you can debug userspace programs via GDB in a limited way.</p>
<h2 id="using-the-debug-stub-in-qemu"><a class="header" href="#using-the-debug-stub-in-qemu">Using the debug stub in QEMU</a></h2>
<p>To debug a program in Twizzler from within QEMU, you can run it under the debug stub program:</p>
<pre><code>debug run &lt;your-program&gt;
</code></pre>
<p>The program will start in a suspended state and wait for a debugger connection. From the host machine,
start GDB in the twizzler source directory. This will run the .gdbinit script and will configure GDB for
debugging Twizzler userspace programs. Note that this file may trigger a warning that it needs to be allowed
to run. If that warning pops up, follow its instructions.</p>
<p>At this point, you should see the (gdb) prompt and it should have connected to the debug stub. If not, you can
try connecting manually via <code>target remote :2159</code>. Note that many features are missing, but are in the process
of being added.</p>
<h2 id="using-the-debug-stub-to-attach-to-a-crashed-compartment"><a class="header" href="#using-the-debug-stub-to-attach-to-a-crashed-compartment">Using the debug stub to attach to a crashed compartment</a></h2>
<p>TODO</p>
<h2 id="some-other-debugging-techniques"><a class="header" href="#some-other-debugging-techniques">Some other debugging techniques</a></h2>
<ul>
<li>Loading of compartments and libraries can be printed by specifying MONDEBUG=1 as an environment variable when starting programs.</li>
<li>Many system services use the tracing crate for logging. You can increase the verbosity by changing the log level in the relevant initialization routines. TODO: get these from environment variables.</li>
<li>The kernel uses the log crate, and its verbosity is controlled in main.rs.</li>
</ul>
<h2 id="working-features"><a class="header" href="#working-features">Working features</a></h2>
<ul>
<li>Reading registers</li>
<li>Reading and poking memory</li>
<li>Tracing stopped threads</li>
</ul>
<h2 id="planned-additional-features"><a class="header" href="#planned-additional-features">Planned additional features</a></h2>
<ul>
<li>Setting / clearing breakpoints (in-progress)</li>
<li>Single stepping (in-progress)</li>
<li>Memory map reading</li>
<li>Multithreaded debugging</li>
<li>Signals</li>
<li>Support for aarch64</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objects"><a class="header" href="#objects">Objects</a></h1>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<p>Objects are an abstraction of a set of related data with the same lifetime and permissions. This vague definition allows for applications to define what data is contained in a single object in a way that is most reasonable for the particular use case. For example, a B-Tree could contain all nodes in the same object given that the nodes likely have the same permissions and lifetime. However, another tree with different permissions for children could separate these nodes into different objects. For this second example, managing their lifetime can be done with <a href="./Lifetime.html#Ties">ties</a>.</p>
<p>Kernel interposition is only done when creating and deleting objects, leaving access and modification to userspace facilities and hardware. Access control is limited by specifying policies and letting hardware enforce those policies. This allows the kernel avoid involvement in access, improving performance without sacrificing security. Objects maintain a reference count to prevent deletion of object data when multiple pointers reference it.</p>
<h2 id="object-creation"><a class="header" href="#object-creation">Object Creation</a></h2>
<p>When creating objects, the medium storing data can be chosen, such as choosing between volatile DRAM and non-volatile memory. While these options are supported by default, other types can be configured based on the hardware support of the particular machine. Different storage mediums provide different benefits and costs and a more in depth discussion can be found at <a href="./Lifetime.html">lifetime</a>.</p>
<p>When creating objects, a source object can be denoted, where the new object will be a copy of the original. This allows for easy versioning, as objects can be copied and kept as different versions. Copying an object uses copy-on-write, meaning another copy of the data is only created when a change is made, rather than immediately on creation.</p>
<h2 id="ids"><a class="header" href="#ids">IDs</a></h2>
<p>While 2<sup>64</sup> object IDs provides a large enough space for a single computer's address space without worries of running out object IDs, adding the ability to generate IDs without having to interact with a central authority and the Twizzler's future of a transparent single id space on a distributed set of computers creates the possibility of collisions. Thus 128 bits are used to shrink the possibility of collisions and the ability to guess an object ID, while also creating a large enough ID space to allow for distribution.</p>
<h3 id="id-derivation"><a class="header" href="#id-derivation">ID derivation</a></h3>
<p>IDs are derived by inputting a nonce, 128 bits of random data, to a hash function. The nonce is provided for objects created using copy-on-write, the objects where a <code>src</code> points to a valid object when calling <code>twz_obj_new()</code> so as to create unique IDs despite having the same object content.</p>
<p>There is also the ability to create object IDs by hashing the contents of the object. This is most useful for conflict-free replicated data types (CRDTs), where multiple computers are running distributed Twizzler and can aggresively replicate objects without worrying about consistency issues. Hashing to obtain an object ID is designed for immutable objects.</p>
<!-- CRDT paper, read and explain
https://hal.inria.fr/hal-00932836/file/CRDTs\_SSS-2011.pdf
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-lifetime"><a class="header" href="#object-lifetime">Object Lifetime</a></h1>
<h2 id="volatile-memory"><a class="header" href="#volatile-memory">Volatile Memory</a></h2>
<p>Placing objects in volatile memory (such as DRAM) limits the object lifetime to at most the time of the next power cycle. This can provide easy cleanup for temporary data, such as the result of computation or cached data kept in memory for locality (faster access).</p>
<p>Objects in volatile memory can be accessed and used in the same ways they are in non-volatile memory.</p>
<h2 id="ties"><a class="header" href="#ties">Ties</a></h2>
<!-- page 7 of Twizzler: a Data-Centric OS for Non-Volatile Memory -->
<p>Ties handle object lifetime by allowing for automatically deleting objects once other constructs are deleted. For example, if an application crashes, the temporary computation might be useless, yet keeping the temporary computation in volatile memory until a power cycle occurs is a waste of that space. Instead, we can tie the lifetime of the object to other objects, such that the object is automatically deleted with the other, freeing the memory before a power cycle. This mechanism is convenient because the kernel does not have to maintain an understanding of the implied lifetime of an object, rather it can be specified relative to other objects.</p>
<p>Ties also provide the benefit of allowing temporary context (such as stacks and heaps) to be stored in persistent memory, allowing for recovery after a power cycle.</p>
<p>For example if we have two objects: <em>koala</em> and <em>coldbrew</em>, tying <em>koala</em> to <em>coldbrew</em> means that <em>koala</em> will not be deleted until after <em>coldbrew</em> is. While <em>koala</em> can be deleted immediately after <em>coldbrew</em> is, if <em>koala</em> is tied to multiple objects, it will only be fully deleted when the final object it is tied to is deleted. Additionally, if <em>koala</em> is tied to a handful of objects, once <strong>all</strong> of those objects are deleted, <em>koala</em> will be automatically deleted too. This is similar to the practice of creating a file and immediately unlinking it within Unix, so the file is automatically deleted once the file descriptor is closed.</p>
<p>Since most construts in Twizzler are just various types of objects, we can use ties to establish a lifetime of objects based on the existence of other objects, such as threads or views. For a more detailed explanation of views, see the <a href="./Views.html">page on views</a>. For temporary computation done in a thread, an instance of computation, objects can be tied to the thread. This provides similar semantics to creating and immediately unlinking files on Unix, as with both, once the application exits, the data is deleted. With views, this provides an address space for an application to run in, possibly over multiple time periods. Tying an object to a view allows the object to exist for as long as the execution state of the application, which could be as long as the application is installed, or only removed when all application data is deleted.</p>
<h3 id="ties-to-volatile-memory"><a class="header" href="#ties-to-volatile-memory">Ties to Volatile Memory</a></h3>
<p>Tying volatile objects to each other implies that both objects will be deleted at a power cycle, which is to be expected. However, things get a little more complicated with ties between volatile and persistent objects. Tying a volatile object to a persistent one breaks the semantics of ties in the event of a power cycle, as the volatile object is deleted and the persistent one is not. However, this outcome is to be expected, and we assume programmers will use this when doing temporary computation. Tying a persistent object to a volatile object is dangerous as both objects will be deleted in the event of a power cycle, including an unexpected one.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pointers"><a class="header" href="#pointers">Pointers</a></h1>
<!-- Page 10-12 of Twizzler: a Data-Centric OS for Non-Volaile Memory -->
<h2 id="definition-1"><a class="header" href="#definition-1">Definition</a></h2>
<p>There are two types of pointers in Twizzler: persistent and dereferenceable. Persistent pointers are used in order refer to external data with no extra context needed. They can be thought of file names on a traditional operating system, where the data exists longer than any process or power cycle. Dereferenceable pointers are references to data in ways that act like traditional memory accesses when programing on other operating systems (such as stack or heap data). Unlike persistent pointers, the data can be acted upon, such as by reading or writing, but additional context is necessary.</p>
<h2 id="rationale"><a class="header" href="#rationale">Rationale</a></h2>
<p>Persistent pointers are much more efficient than file I/O, as there is a link to data from the pointer without the need for deserialization of a file. This just allows links of data in data structures, which is what objects are.</p>
<h2 id="foreign-object-table"><a class="header" href="#foreign-object-table">Foreign Object Table</a></h2>
<p>Persistent pointers work by indexing into a Foreign Object Table (FOT), which holds a longer reference to the data, allowing for late binding of names. Late binding in FOTs are explained in more detail in a <a href="Pointer.html#late-binding">later section</a>. Persistent pointers are thus just an index of external object wanted (16 bits, allowing for 65,536 object references), and an offset within the foreign object (40 bits, a maximum offset of 1 terabyte). Because access control is at an object granularity, multiple pointers to the same object can use the same FOT entry.</p>
<h3 id="late-binding"><a class="header" href="#late-binding">Late-Binding</a></h3>
<p>Late binding of names is used often with libraries to allow for updates of the library without requiring every program using the library to be recompiled. In Twizzler, late-binding is done by putting a name as the entry in the FOT. When creating the FOT entry, a name resolver can also be specified to allow for different objects to have different name resolvers. The actual name resolution happens when converting the persistent pointer to a dereferenceable one, allowing for different objects to be resolved at different times, just based on the name at dereference time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="permissions"><a class="header" href="#permissions">Permissions</a></h1>
<p>A thread has permission to access an object if:</p>
<ul>
<li>They have not been restricted by a mask (including global mask)</li>
<li>The thread has the capability, or delegated capability. (by attaching to a security
context).</li>
<li>The thread knows the object's name. (security by obscurity)</li>
</ul>
<h2 id="permission-values-for-objects"><a class="header" href="#permission-values-for-objects">Permission values for objects</a></h2>
<p>There are 5 permissions an object can have: read, write, execute, use, and delete. Except for use (and to an extent delete), these permissions exist in Unix systems, and are used in the same way.</p>
<ul>
<li><strong>Read:</strong> This allows a thread the ability to look at the contents of an object.</li>
<li><strong>Write:</strong> This allows a thread the ability to modify an object. </li>
<li><strong>Execute:</strong> The object can be run as a program.</li>
<li><strong>Delete:</strong> The object can be deleted. Usually Unix systems include this as part of write
permissions, and Windows systems allow this to be a separate permission.</li>
<li><strong>Use:</strong> This marks the object as available for the kernel to operate on, such as a kernel state
object, further explained on <a href="./KSO.html">kernel state objects</a>. Often times this is used for attaching a thread to a security context.</li>
</ul>
<h2 id="masks"><a class="header" href="#masks">Masks</a></h2>
<p>Masks further restrict permissions to objects. This is similar to <code>umask</code> in Unix systems. For example, while by default any object may have access to an object called <em>bloom</em>, we may want a specific security context called <em>Fall</em> to not have access to the object.</p>
<p>We do not need signatures on masks because they are part of the security context, meaning threads can only modify the mask if they can modify the security context object.</p>
<h2 id="capabilities"><a class="header" href="#capabilities">Capabilities</a></h2>
<p>Capabilities are when permissions a provided to objects as tokens, where the program can access the data if it has a valid token. Unlike previous implementations of capability systems, Twizzler includes an object ID as part of the capability signature to prevent a capability from being stolen by leaking the signature to malicious parties. While this does require identity to be checked in addition to the validity of the signature, this prevents simple leaks of secrets from breaking the security of an object.</p>
<h2 id="delegation"><a class="header" href="#delegation">Delegation</a></h2>
<p>Delegation allow for capabilities to be shared and futher restricted with other views. In order to delegate a capability, it must have high permissions within the object it wishes to delegate (enough so as to access the private key of the object).</p>
<h2 id="late-binding-access-control"><a class="header" href="#late-binding-access-control">Late Binding Access Control</a></h2>
<p>Rather than checking an object when it is initially accessed, such as in Unix with a call to <code>open()</code>, Twizzler checks access at the time when the operation is done, such as a read or write. This means that a thread can open an object with more permissions than allowed and not cause a fault, and only once that illegal operation is attempted will the fault occur.</p>
<p>This method for enforcing access control is different from Unix systems because the kernel is not involved for memory access, which is how Twizzler formats all data. However protection still exists because when loading a security context, the MMU is programmed to limit access.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime"><a class="header" href="#runtime">Runtime</a></h1>
<h2 id="programs-in-twizzler"><a class="header" href="#programs-in-twizzler">Programs in Twizzler</a></h2>
<p>A standard Rust program running on Twizzler links to two libraries (at a minimum):</p>
<ul>
<li>libstd.so, the Rust standard library</li>
<li>A Twizzler Runtime, exporting the Twizzler Runtime ABI</li>
</ul>
<p>The Rust standard library, when targeting Twizzler, expects the Twizzler Runtime
to exist (in particular, a number of functions defined prefixed by twz_rt_). Thus
programs targeting Twizzler will need to pick a runtime to use, and a compilation
method. Right now there are really only two options: minimal runtime (with static
compilation) or the reference runtime (with dynamic compilation). </p>
<p>The reference runtime is more featureful and is the default. The default Twizzler
target will compile programs as dynamic executables that can link (dynamically) to
the standard library, the reference runtime (and the monitor), and any other
dynamic libraries. No additional setup is needed for this.</p>
<p>Another option is the minimal runtime. This runtime doesn't depend on libstd, nor
on the security monitor or other OS features other than the kernel. Currently, this
runtime option only supports static linking, and as a result, some additional work
is needed to make it happen. This is not officially supported, however, and I suggest
you stick to the default, above. If you insist that you want this, however, take a
look at src/bin/bootstrap's Cargo.toml.</p>
<h2 id="the-runtime-abi"><a class="header" href="#the-runtime-abi">The Runtime ABI</a></h2>
<p>The ABI for the runtimes is defined in the src/abi submodule. This submodule contains
header files that are fed into bindgen to generate the actual ABI and API definitions.
The reason is that this way we can support additional languages in the future, as long
at they can talk C ABI. In any case, the src/abi/rt-abi crate contains the bindings for
the generated runtime ABI as well as a set of convenience functions for calling those
with a more Rust-like interface.</p>
<h2 id="abi-version-compatibility"><a class="header" href="#abi-version-compatibility">ABI Version Compatibility</a></h2>
<p>When compiling, the build system will check the version of the installed toolchain
(the one built and installed by cargo bootstrap) and compare it to the version in
the source tree. If either the Rust commit ID or the crate version of twizzlert-rt-abi
differ between the source tree and the installed version, the build system will error
out and refuse to compile.</p>
<p>In the future, we plan to use semver to make this check less strict.</p>
<h1 id="the-twizzler-reference-runtime"><a class="header" href="#the-twizzler-reference-runtime">The Twizzler Reference Runtime</a></h1>
<p>The primary runtime environment supported by Twizzler is the <em>Reference
Runtime</em>. It provides userspace functionality for programs, the ability to load
programs and libraries, and the ability to isolate those programs and libraries
from each other.</p>
<p>TODO</p>
<h1 id="the-twizzler-minimal-runtime"><a class="header" href="#the-twizzler-minimal-runtime">The Twizzler Minimal Runtime</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="views"><a class="header" href="#views">Views</a></h1>
<p>Views are an address space abstraction that sets an environment for threads to run in. Persistent objects are mapped into the view and given dereferenceable virtual pointers. These virtual pointers allow access to the object inside the view.</p>
<p>Because views are normal objects, they can be written on persistent memory and allow recovery of application state in the event of a crash or power cycle. The abstraction ov views also allows easy sharing of thread state, such as references to data. This is convient as it allows for sharing of data without requiring serialization through a construct like a pipe or file, and without the need of a call to <code>mmap</code>. Sharing views with other threads does provide a security threat, as one thread could corrupt the view for both. To deal with this security vulnerability, there is the abstraction of <a href="./Gates.html">secure API calls/gates</a> which allows communication between threads without allowing one or the other to corrupt another's data.</p>
<p>When a thread wants to map a new object into the view, they can call _____ and when they attempt to access the object, the kernel will automatically map it in. To change or remove an entry, the kernel must be involved with the function <code>invalidate_view()</code>, to update references to the underlying memory.</p>
<p>To switch between views, the system call <code>become()</code> is needed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-state-objects"><a class="header" href="#kernel-state-objects">Kernel State Objects</a></h1>
<p>These are normal objects used by both userspace programs and the kernel. For them to be used by the kernel, the use permission must be set. To learn more about the use permission, see <a href="./Permissions.html">Permissions</a>.</p>
<h2 id="security-contexts"><a class="header" href="#security-contexts">Security Contexts</a></h2>
<p>A security context is an object that contains information about which objects can be accessed and how (such as managing capabilities). A thread attaches to the security context to gain access to the objects. This can be useful for operations similar to the <code>sudo</code> command on UNIX, where privileges are temporarily increased in order to perform certain privileged operations without fully changing user ID.</p>
<p>Additionally, security contexts can be used to limit permissions. To prevent a limited thread from shedding their limited permission state, attached contexts can be set as undetachable.</p>
<!-- TODO: Add section about invalidating cached data of security context when the context is updated or an item is removed --><div style="break-before: page; page-break-before: always;"></div><h1 id="extensions"><a class="header" href="#extensions">Extensions</a></h1>
<p>This is the interface abstraction in many programming languages, or the functions that must be implemented for drivers, such as <code>read()</code> and <code>write()</code>. In practice, Twizzler's implementation of this applies to objects, where a set of methods are defined and noted such that external threads accessing the object can call the interface methods without a need to understand the specifics of under the hood operations for the object.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Two examples of extensions are IO and Event. IO is useful for reading and writing to an object, and for an object to support the extension, the object must implement the functions <code>read()</code>, <code>write()</code>, <code>ioctl()</code>, and <code>poll()</code>. When registering the extension, the object will provide pointers to all of the functions, so calls to <code>read()</code> for example on the object will know how to implement the function in an object specific way.</p>
<p>Event is a way of waiting for something to happen to an object, similar to <code>poll()</code> on a file descriptor in Unix. Specific events can be waited for by using <code>event_wait()</code> with the object and event passed in as arguments. Because this is just an interface, an object can implement it in a way that makes sense to it, such as waiting for data from a network or a write to an object to complete.</p>
<h2 id="tags"><a class="header" href="#tags">Tags</a></h2>
<p>Tags are a way of uniquely identifying an extension, such as IO, and checking if the object supports the extension. These are stored in the metadata for the object, and when the tag is added to the metadata, a pointer to the functions that implement the interface are also added.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gates"><a class="header" href="#gates">Gates</a></h1>
<p>Gates, also known as secure API calls, are a means of exposing a limited set of functions available to an external user. This is similar to system calls, where the user can call into the kernel to do specific actions. Gates are used for interprocess communication.</p>
<p>Gates are a way of an object exposing a system call like interface. This allows an object to define arbitrary behavior other threads can call. Because external threads can only access the object through the gate, they are restricted from detrimental actions, provided the gate is correctly written. While this does place the responsibility for secure code in the hands of any programmer rather than the typical relegation of secure code to security experts, gates are optional and can be avoided if there is worry about security flaws.</p>
<p>When writing gates, best security practices are required to avoid vulnerabilities in the gates. As such, beware of timing attacks and other side channels that can be used to subtly exploit the object.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-memory-access-dma"><a class="header" href="#direct-memory-access-dma">Direct Memory Access (DMA)</a></h1>
<p>A key aspect of a device driver involves programming the device to access host memory. When a device
accesses host memory, we usually call it Direct Memory Access (DMA). DMA is used, for example, by
NICs to access transmit rings, or to copy packet data into main memory (memory that the CPU, and
thus the OS and user programs can access). However, devices access main memory differently to how
threads running on a CPU access memory. Before we discuss the API that Twizzler provides for DMA, we
should discuss how devices access memory, and the implications this has for memory safety,
translation, and coherence.</p>
<h2 id="considerations-for-dma"><a class="header" href="#considerations-for-dma">Considerations for DMA</a></h2>
<p>When programs access memory in Twizzler they do so via accessing object memory, which involves an
MMU translating some kind of object address to a physical address. On x86, for example, this
involves a software translation to a virtual address followed by a translation via the Memory
Management Unit (MMU) to a physical address. Similarly, when a device accesses memory, it emits a
memory address (likely programmed by the driver) that may undergo no translation or some other
translation on the bus before attempting to access host memory. There are two important
considerations that are the result of this alternate (or no) translation:</p>
<ul>
<li><strong>Contiguous addresses</strong>. While object memory is contiguous (within an object), the physical memory that
backs that object memory may not be. Devices and drivers need to be capable of handling access
to memory in a scatter-gather manner.</li>
<li><strong>Access Control</strong>. Access control can be applied differently between host-side driver software and
devices. Thus driver software must be aware that it may have access to memory via the device that it
should not directly. We can use devices like the IOMMU to limit this effect.</li>
</ul>
<p>In addition to the above, we need to consider the issue of coherence. While CPU caches are coherent
across cores, devices accessing host memory do not necessarily invalidate caches. Thus we have to
handle both flushing data to main-memory after writing before the device reads it and invalidating
caches if a device writes to memory. Some systems automatically invalidate caches, but not all do.</p>
<h3 id="memory-safety"><a class="header" href="#memory-safety">Memory Safety</a></h3>
<p>Finally, we must consider memory safety. While we can control writes from host software to DMA
buffers, we cannot necessarily control how the device will access that memory. To ensure memory
safety of shared regions, need to ensure:</p>
<ol>
<li>The device and host software cannot both mutate shared state at the same time (thread safety),
or if this can happen, then the shared memory region that can be updated by both entities is
comprised of atomic variables.</li>
<li>The device mutates data such that each mutation is valid for the ABI of the type of the memory
region.</li>
</ol>
<p>Enforcing these at all times would add significant overhead. We take some inspiration from Rust's
stance on <a href="https://doc.rust-lang.org/std/os/unix/io/index.html#procselfmem-and-similar-os-features">external influences to
memory</a>,
tempering this somewhat with the addition of a <code>DeviceSync</code> marker trait.</p>
<h2 id="overview-of-dma-system"><a class="header" href="#overview-of-dma-system">Overview of DMA System</a></h2>
<p>The Twizzler DMA system is contained within the twizzler-driver crate in the <code>dma</code> module. The
module exposes several types for using Twizzler objects in DMA operations along with an abstraction
that enables easier allocation of DMA-able memory. The key idea behind Twizzler's DMA operation is
that one can create a <code>DmaObject</code>, from which one can create a <code>DmaRegion</code> or a <code>DmaSliceRegion</code>.
These regions can then be &quot;pinned&quot;, which ensures that all memory that backs them is locked in place
(the physical addresses do not change), and the list of physical addresses that back the region are
made available for the driver so that it may program the device.</p>
<h3 id="coherence-and-accessing-memory"><a class="header" href="#coherence-and-accessing-memory">Coherence and Accessing Memory</a></h3>
<p>The primary way that the driver is expected to access DMA memory is through the <code>DmaRegion</code>'s <code>with</code>
or <code>with_mut</code> method. These functions take a closure that expects a reference to the memory as
argument. When called, the <code>with</code> function ensures coherence between the device and the CPU, and
then calls the closure. The <code>with_mut</code> function is similar, except it passes a mutable reference to
the closure and ensures coherence after the closure runs as well.</p>
<p>The <code>DmaSliceRegion</code> type provides similar <code>with</code> functions, except they take an additional <code>Range</code>
as argument that can be used to select only a subslice of the region that the closure gets access
to. Allowing for subslicing here is useful because it allows the driver to communicate to the
library which parts of the region need coherence before running the closure.</p>
<h3 id="access-directions-and-other-options"><a class="header" href="#access-directions-and-other-options">Access Directions and Other Options</a></h3>
<p>Regions can be configured when they are created for various different use cases.</p>
<p>The <strong>Access Direction</strong> refers to which entities (the device and the CPU) may read and write the
memory. Driver writers should pick the most restricted (but correct) mode they can, as is can have
implications for maintaining coherence. It can have one of three values:</p>
<ul>
<li>HostToDevice: The memory is used for the host to communicate to the device. Only the host may
write to the memory.</li>
<li>DeviceToHost: The memory is used for the device to communicate to the host. The host may not
write to the memory.</li>
<li>BiDirectional: Either entity may write to the memory.</li>
</ul>
<p>In addition to access direction, regions can be configured with additional options, a bitwise-or of
the following flags:</p>
<ul>
<li>UNSAFE_MANUAL_COHERENCE: The <code>with</code> functions will not perform any coherence operations. The
driver must manually ensure that memory is coherent.</li>
</ul>
<h3 id="pinning-memory"><a class="header" href="#pinning-memory">Pinning Memory</a></h3>
<p>Before a device can be programmed with a memory address for DMA, the driver must learn the physical
address that backs the DMA region while ensuring that that address is stable for the lifetime of
whatever operation it needs the device to perform. Both of these are taken care of with the <code>pin</code>
function on a <code>DmaRegion</code> or <code>DmaSliceRegion</code>. The <code>pin</code> function returns a <code>DmaPin</code> object that
provides an iterator over a list of <code>PhysInfo</code> types, which can provide the physical address of a
page of memory.</p>
<p>A region of DMA memory that comprises some number of pages (contiguous in virtual memory) can
list the (likely non-contiguous) physical pages that it maps to. The order that the pages are
returned in is the order that they appear for backing the virtual region. In other words, the 4th
<code>PhysInfo</code> entry in the iterator of a <code>DmaPin</code> for a region contains the physical address of the 4th
virtual page in the DMA region.</p>
<p>Any future calls to <code>pin</code> return another <code>DmaPin</code> object, but the underlying pin information (that
is, the physical addresses) may be the same, even if the <code>DmaRegion</code> is dropped and recreated.
However, if the <code>DmaObject</code> is dropped and recreated, the driver cannot rely on the pin to be
consistent. More specifically, the pin's lifetime is tied to the <code>DmaObject</code>, not the <code>DmaRegion</code>.
The reason for this somewhat conservative approach to releasing pins is to reduce the likelihood of
memory corruption from accidental mis-programming. Another consideration for pinned memory lifetime
is that it can leak if the driver crashes. Allowing for leaks in this case is intentional, as it
makes it less likely that the device will stomp over memory in the case of a driver crash.</p>
<h3 id="pools"><a class="header" href="#pools">Pools</a></h3>
<p>While we can use a <code>DmaObject</code> to perform DMA on an existing Twizzler object, it is common for a
device driver to need a simple pool of DMA-able memory that it can allocate from so that it may
communicate with the device (e.g. DMA memory for a ring buffer). For this, twizzler-driver provides
a <code>DmaPool</code> type that can be used to allocate DMA regions that share an access type and a set of
<code>DmaOptions</code>. The pool will internally create new Twizzler objects that it uses to allocate DMA
memory from, which it then uses to create DMA regions on-demand.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracing-and-performance-debugging"><a class="header" href="#tracing-and-performance-debugging">Tracing and Performance Debugging</a></h1>
<p>Twizzler supports tracing facilities supported by the kernel. A utility program, <code>trace</code>, enables
users to trace programs and collect statistics, thread sampling events, and other kernel events that
may impact performance. The twizzler-abi crate provides a trace submodule that contains data definitions for tracing events.</p>
<p>Do note that this work is in early stages, and as such, not all defined tracing events may be supported or generated. If you would like one added, feel free to open a PR or issue! Also note
that the standard issues of tracing performance issues apply: you are interfering with the system
by tracing it, and thus it may behave differently under tracing. The tracing system attempts to be
as lightweight as possible so as to minimize this effect, but it cannot be nullified completely.</p>
<h2 id="tracing-user-programs"><a class="header" href="#tracing-user-programs">Tracing user programs</a></h2>
<p>The <code>trace</code> program provides functionality to trace user programs. It allows users to specify the target program and the events to be traced:</p>
<pre><code>trace -e syscalls ls
</code></pre>
<p>This will trace the <code>ls</code> program and collect information on each syscall that the tracee makes.
The currently supported events for -e are (specified abbreviations also work): syscalls (sys), page-faults (pf), tlb. More will be added in the future, as well as a flag to ask trace what
events are supported directly.</p>
<pre><code>trace -s ls
</code></pre>
<p>This will sample the threads running in the <code>ls</code> compartment at regular intervals and collect statistics on each thread's execution. It may be useful to specify the MONDEBUG=1 environment
variable so as to show which libraries are loaded where.</p>
<h2 id="todo"><a class="header" href="#todo">TODO</a></h2>
<ul>
<li>Allow changing sampling rate</li>
<li>Allow more fine-grained sampling (requires kernel scheduler changes)</li>
<li>Provide list of -e events from trace program directly</li>
<li>Parse the debug info for the compartment so that we can output symbol names instead of addresses.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-metadata-for-twizzler-crates-built-inside-xtask"><a class="header" href="#cargo-metadata-for-twizzler-crates-built-inside-xtask">Cargo metadata for Twizzler crates built inside xtask</a></h1>
<p>The xtask program organizes the build into a series of &quot;collections&quot; that get built in different environments. There are:</p>
<ul>
<li>Tools (targets build system)</li>
<li>Kernel (targets arch-machine-none)</li>
<li>Userspace (targets arch-machine-twizzler, optional, default yes)</li>
<li>Userspace-static (targets arch-machine-twizzler-minruntime, optional, default yes)</li>
<li>Userspace-tests (targets arch-machine-twizzler-minruntime, optional, default no)</li>
<li>Kernel-tests (targets arch-machine-none, optional, default no)</li>
</ul>
<p>Programs may select which collection to be compiled in based on the metadata value set in Cargo.toml, described in more detail below.</p>
<h2 id="static-versus-non-static-builds"><a class="header" href="#static-versus-non-static-builds">Static versus non-static builds</a></h2>
<p>Twizzler currently builds packages in two <code>target_env</code> settings: &quot;minruntime&quot; and &quot;&quot;. This translates to two triples that are used for userspace twizzler programs: arch-machine-twizzler, and arch-machine-twizzler-minruntime. The minruntime variant is defined to be for statically linked programs, using the default minimal runtime provided by twizzler-abi. Such crates can declare that they should be compiled only in the minruntime collection by setting the key <code>package.metadata.twizzler-build</code> to &quot;static&quot; in Cargo.toml:</p>
<pre><code class="language-{toml}">[package.metadata]
twizzler-build = &quot;static&quot;
</code></pre>
<h2 id="tools"><a class="header" href="#tools">Tools</a></h2>
<p>Tools should be placed in the tools subdirectory, and should set the <code>package.metadata.twizzler-build</code> key to &quot;tool&quot; in Cargo.toml:</p>
<pre><code class="language-{toml}">[package.metadata]
twizzler-build = &quot;tool&quot;
</code></pre>
<h2 id="the-kernel-and-xtask"><a class="header" href="#the-kernel-and-xtask">The kernel and xtask</a></h2>
<p>Both the kernel and xtask themselves set the <code>package.metadata.twizzler-build</code> key to &quot;kernel&quot; or &quot;xtask&quot;. Programs should not use these values. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assorted-notes"><a class="header" href="#assorted-notes">Assorted Notes</a></h1>
<h2 id="updating-the-toolchain"><a class="header" href="#updating-the-toolchain">Updating the toolchain</a></h2>
<ol>
<li>Update the repos. Go into toolchain/src/rust and, for each of ., library/libc, library/backtrace, and src/llvm-project, you'll need to:
a. Add the upstream remote (usually github rust-lang/<name of repo>, though backtrace is called &quot;backtrace-rs&quot; there)
b. Ensure you've fetched the twizzler branch from origin, and the following branches from upstream:
- libc: &quot;libc-2.0&quot;
- bracktrace: &quot;master&quot;
- llvm-project: you'll need to look at the upstream repo and determine the latest version number, looking at the branches on github.
- .: master</li>
<li>Checkout master for rust (.), ensure that this checks out the new submodule commits too.</li>
<li>Rebase the submodules. For each of libc, backtrace, and llvm-project, you'll need to go into that directory and rebase the twizzler branch onto the current commit.</li>
<li>Rebase the twizzler branch onto master in the rust repo. There will probably be conflicts and compile errors.</li>
<li>Commit all the submodules, push, and do the same for the rust repo.</li>
<li>Test...
Done!</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
